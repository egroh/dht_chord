searchState.loadedDescShard("dht_chord", 0, "This repository showcases a Rust P2P-DHT-Chord …\nProvides a server socket for API communication\nImplementation of a distributed hash table based on Chord\nAnswer to a failed <code>API_DHT_GET</code> request\nRequests the DHT to retrieve a value\nRequests the DHT to store a value\nRequests our DHT node to shutdown\nAnswer to a successful <code>API_DHT_GET</code> request\nInternal representation of all packages received on the …\nHeader of an <code>ApiPacket</code>\nContent of an <code>ApiPacket</code>\nInternal representation of a <code>DHT_GET</code> request\nInternal representation of a <code>DHT_FAILURE</code> response\nInternal representation of a <code>DHT_SUCCESS</code> response\nInternal representation of a <code>DHT_PUT</code> request\nReserved for future use\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFixed size 256 bit key (we hash all keys into a 64 bit …\nIndicates the type of the message with a well-known …\nHow many copies of the value should be stored in the DHT\nThe size indicates the total length of a message, <em>including</em>…\nTime-to-live of the value in seconds\nValue of arbitrary size\nDistributed Hash Table\nAll data necessary for DHT operation\nHandle incoming request from a connecting peer.\nOur outward facing address.\nReturns whether this node is responsible for a given key.\nReturns a <code>ChordPeer</code> representing this node; useful for …\nReturns a result with the predecessor of <code>node_to_ask</code>. If …\nAsks a <code>ChordPeer</code> for its successor\nAsserts that we do not contain ourselves in the finger …\nCalculate hash for ID-mapping\nThe default amount of replications which are done for each …\nDefault storage duration of entries, if not specified …\nThe characteristic Chord jump table. We maintain 64 …\nIterates through all finger table entries and asks the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nQueries the network for a given key and returns its …\nReturns the predecessor of this node. If we do not have a …\nReturns the <code>ChordPeer</code> responsible for a given key.\nPerforms the housekeeping which performs some periodic …\nReturns the id which is <code>2^index</code> after this node\nInserts a key value pair into the network\nInserts an entry into our local <code>node_storage</code>, alongside …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a key is between two keys/nodes on the ring\nThe maximum duration for which we keep an item we have …\nConstruct new instance of chord.\nOur own Node-ID.\nThe node storage keeps track of entries that have been …\nCommunication between peers\nThe personal storage keeps track of entries we have been …\nList of predecessors do determine key responsibility and …\nSends a <code>ProofOfWorkChallenge</code> to the connected peer and …\nSolves a <code>ProofOfWorkChallenge</code> and sends the corresponding …\nStabilized this node\nAttempts to contact the predecessor at the given index. If …\nAttempts to contact the given successor. If the successor …\nMethod to start the housekeeping thread\nStarts the server socket to listen for incoming peer …\nUniquely identifies a peer in our network\nSignals intent to gracefully close the connection; acting …\nGet node responsible for key\nResponse to <code>PeerMessage::GetNode</code>\nRetrieves the predecessor of a node\nResponse to <code>PeerMessage::GetPredecessor</code>\nGet value from responsible node\nResponse to <code>PeerMessage::GetValue</code>\nInsert value into responsible node\nAll communication messages sent between peers\nSHA-3-512 based proof-of-work challenge\nRequests a node to solve a <code>ProofOfWorkChallenge</code>\nResponse to <code>PeerMessage::ProofOfWorkChallenge</code>\nResponse to <code>PeerMessage::ProofOfWorkChallenge</code>\nSets the predecessor of a node\nSets the successor of a node\nRequests a node to split\nResponse to <code>PeerMessage::SplitRequest</code>\nResponse to <code>PeerMessage::SplitRequest</code>\nAddress under which we can reach the peer\nChecks if the given response is a valid solution to this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNode-ID of the peer (currently a hash of the address a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new proof-of-work challenge with the given …\nTo solve the challenge, an integer must be found, that …")